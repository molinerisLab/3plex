---
title: "R Notebook"
output: html_notebook
---


```{r}
# Resources
library(ggplot2)
library(ggpubr)
library(dplyr)
library(pROC)
library(ggsci)

# Dataframe
df <- read.table("tpx_paramspace_AUC.ALL_noSingleNt.method.Npeaks_version.noPROB_fitted.noT_pot_custom.technique.header_added.gz", header=T)

# Set params as factors and relevel 
groups_factors <- c("peak_method_all","ssRNA","singleStrandedness","min_len","error_rate","guanine_rate","repeat_filter","consecutive_error","predictor","technique")
df[,groups_factors] <- lapply(df[,groups_factors] , factor)
df$predictor <- relevel(df$predictor, ref = "t_pot_norm")
df$technique <- relevel(df$technique, ref = "ChIRP-seq")
df$min_len <- relevel(df$min_len, ref = "10")
df$singleStrandedness <- relevel(df$singleStrandedness, ref = "ss50")


# Remove "stability_norm_overcount"
df <- df[!grepl("Stability_norm_overcount", df$predictor),]

# remove AC087482.1 from idr_conservative peaks ??
# df <- 
```



## Check for data normality

```{r}
# Density plot
for (factor in groups_factors) {
  p <- ggplot(df, aes(y = AUC)) + 
    geom_density(aes_string(fill = factor), position = 'identity', alpha = 0.5) +
    coord_flip()
  print(p)
}
```


```{r}
qqPlot(df$AUC)
```


# Linear model


```{r}
# groups to be investigated
groups <- colnames(df)[!colnames(df) %in% "AUC"]

# formula with all groups
formula_full <- as.formula(paste("AUC ~ ", paste(groups, collapse="+")))

# Linear model with all groups
model_full <- lm(formula_full, data = df)

print(formula_full)
summary(model_full)
```


##########################

BEST PARAMETER SETTINGS:

- v8.2_ReChIRP_idr_cons
- ss0
- min len 8
- error rate 20
- repeat_filter off
- consecutive_error 3
- PROB__fitted_model == Stability_norm_undercount

##########################


```{r}
tapply(df$AUC, df$peak_method_all, mean)
```





# Difference between reference and other levels of each group

```{r}
sm <- summary(model_full)
m <- as.data.frame(sm[["coefficients"]])
colnames(m) <- c("Estimate","StdError","tvalue","Prt")

grp <- c("peak_method_all", "predictor", "min_len", "singleStrandedness","technique")

for (g in grp) {
  mg <- m[grepl(g, rownames(m)), ]
  mg <- rbind(c(0,0,0,0),mg)
  print(mg)
  r <- levels(df[,g])
  print(r)
  #r <- gsub(g, "", rownames(mg))
  p <- ggplot(mg, aes(x=rownames(mg),y=Estimate)) + 
    geom_bar(stat="identity", color="black", fill="gray") +
    geom_errorbar(aes(ymin=Estimate-StdError, ymax=Estimate+StdError), width=.2,
                 position=position_dodge(.9)) +
    scale_x_discrete(labels = r) +
    theme_pubr(base_size = 8) +
    xlab("") + ylab("coeff variation") +
    theme(axis.text.x = element_text(angle = 45, vjust = 0.5)) 
  print(p)
}
```





```{r}
# Riproduco il modello lineare escludendo ssRNA perchè colineare con technique

# groups to be investigated
groups <- colnames(df)[!colnames(df) %in% c("AUC","ssRNA")]

# formula with all groups
formula_full <- as.formula(paste("AUC ~ ", paste(groups, collapse="+")))

# Linear model with all groups
model_full <- lm(formula_full, data = df)

print(formula_full)
summary(model_full)
```



```{r}
sm <- summary(model_full)
m <- as.data.frame(sm[["coefficients"]])
colnames(m) <- c("Estimate","StdError","tvalue","Prt")

grp <- c("technique")

for (g in grp) {
  mg <- m[grepl(g, rownames(m)), ]
  mg <- rbind(c(0,0,0,0),mg)
  print(mg)
  r <- levels(df[,g])
  print(r)
  #r <- gsub(g, "", rownames(mg))
  p <- ggplot(mg, aes(x=rownames(mg),y=Estimate)) + 
    geom_bar(stat="identity", color="black", fill="gray") +
    geom_errorbar(aes(ymin=Estimate-StdError, ymax=Estimate+StdError), width=.2,
                 position=position_dodge(.9)) +
    scale_x_discrete(labels = r) +
    theme_pubr(base_size = 8) +
    xlab("") + ylab("coeff variation") +
    theme(axis.text.x = element_text(angle = 45, vjust = 0.5)) 
  print(p)
}
```






## CHECK FOR LINEAR MODEL ASSUMPTIONS

1) LINEARITY - If the dependent variable is linearly related to the independent variables,
there should be no systematic relationship between the residuals and the
predicted (that is, fitted) values

2) NORMALITY - If the dependent variable is normally distributed for a fixed set of
predictor values, then the residual values should be normally distributed with a
mean of 0. The Normal Q-Q plot is a probability plot of the standardized
residuals against the values that would be expected under normality. If
you’ve met the normality assumption, the points on this graph should fall on the
straight 45-degree line.

3) HOMOSCEDASTICITY - If you’ve met the constant variance assumption, the points in
the Scale-Location graph should be a random band around a horizontal
line.

4) OUTLIERS - The Residual versus Leverage graph provides information on
individual observations that you may wish to attend to. The graph identifies outliers,
high-leverage points, and influential observations

```{r}
plot(model_full)
```


## INDEPENDENCE OF ERRORS 

A nonsignificant p-value suggests a lack of autocorrelation, and conversely
an independence of errors.
The lag value (1 in this case) indicates that each observation
is being compared with the one next to it in the dataset.

```{r}
durbinWatsonTest(model_full)
```


## OUTLIERS

```{r}
outlierTest(model_full)
```





### ANOVA ANALYSIS ###

# Calculates type-II or type-III analysis-of-variance tables for model objects produced by lm, glm, multinom ecc.
For linear models, F-tests are calculated.

```{r}
# considering ssRNA

tpx.aov <- anova(model_full)
print(tpx.aov)
print(summary(tpx.aov))
```


```{r}
# considering technique

tpx.aov <- anova(model_full)
print(tpx.aov)
print(summary(tpx.aov))
```



# Fit an analysis of variance model by a call to lm for each stratum
aov fits a model (as you are already aware, internally it calls lm), so it produces regression coefficients, fitted values, residuals, etc; It produces an object of primary class "aov" but also a secondary class "lm". So, it is an augmentation of an "lm" object.

```{r}
# considering ssRNA
formula_pairwise = as.formula("AUC ~ peak_method_all + technique + singleStrandedness + min_len + predictor")
tpx.aov2 <- aov(formula_pairwise, data = df)
print(tpx.aov2)
print(summary(tpx.aov2))
```




## BOXPLOTS FOR CATEGORICAL VARIABLES

```{r}
for (group in groups_factors) {
  p <- ggplot(df, aes_string(x = group, y = "AUC")) + 
    geom_boxplot(notch = T, outlier.shape = NA) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=0.5))
  print(p)
}
```


## SCATTERPLOT FOR NUMERIC VARIABLES

```{r}
#groups_num <- c("frip","rescue_ratio","self_consistency_ratio","n_peaks")
groups_num <- c("n_peaks")
for (group in groups_num) {
  p <- ggplot(df, aes_string(x = group, y = "AUC")) + 
    geom_point(size = 0.5) +
    theme_bw()
  print(p)
}
```



## PAIRWISE COMPARISONS

Valenza in media per tutti i lncRNA

```{r}
group_pairwise <- c("peak_method_all", "technique", "singleStrandedness", "min_len", "predictor")
pwc <- TukeyHSD(tpx.aov2, which = group_pairwise, conf.level=0.95, ordered = T)
suppressMessages(print(pwc))
plot(pwc, las=1 , col="brown")
```



```{r}
# https://stackoverflow.com/questions/33644034/how-to-visualize-pairwise-comparisons-with-ggplot2

aov_ssRNA <- aov(formula_full, data = df)
print(aov_ssRNA)
print(summary(aov_ssRNA))

pairwise_groups <- c("peak_method_all", "singleStrandedness", "min_len", "predictor")

for (pg in pairwise_groups) {
  
  print(pg)
  
  tky <- as.data.frame(TukeyHSD(aov_ssRNA, pg, ordered = T)$pg)
  tky$pair <- rownames(tky)
  
  print(tky)
  
  # Plot pairwise TukeyHSD comparisons and color by significance level
  p <- ggplot(tky, aes(color=cut(`p adj`, c(0, 0.01, 0.05, 1), label=c("p<0.01","p<0.05","Non-Sig")))) +
    geom_hline(yintercept=0, lty="11", colour="grey30") +
    geom_errorbar(aes(pair, ymin=lwr, ymax=upr), width=0.2) +
    geom_point(aes(pair, diff)) +
    labs(colour="") +
    coord_flip() +
    theme_pubr(base_size = 8) +
    xlab("") + ylab("") +
    scale_color_manual(values = c("p<0.01" = "#a70000",
                                    "p<0.05" = "#ff7b7b",
                                    "Non-Sig" = "grey"))
  
  print(p)
}


```



# Compute empirical p-values

```{r}
# considering ssRNA
null_dist <- read.table("tpx_paramspace_AUC.ALL_noSingleNt.method.Npeaks_version.noPROB_fitted.noT_pot_custom.anova_exclude.gz"
                , header = F
                , col.names = c("param","pval"))

true_values <- read.table("tpx_paramspace_AUC.ALL_noSingleNt.method.Npeaks_version.noPROB_fitted.noT_pot_custom.header_added.true_prediction"
                          , header = F
                          , col.names = c("param","pval"))

null_dist_split <- split(x = null_dist, f = null_dist$param)

for (group in groups) {
  true_pval <- true_values[which(true_values$param == group),2]
  empirical_pval <- sum(null_dist_split[[group]][["pval"]] < true_pval)/10000
  print(group)
  print(empirical_pval)
}
```

# Supplementary table
https://docs.google.com/document/d/1qIz3bUYIxNy6AoWychLggRhHYdeeNow2F1uLvAigX1E/edit?disco=AAAAY4YF7P8

```{r}

```

0: < 1e-4

min len rilevante, quale è migliore? confronti oppure guardo modello lineare


```{r}
for (group in groups) {
  ndf <- null_dist_split[[group]]
  p <- ggplot(ndf, aes(y = pval)) + geom_density() + coord_flip() + ggtitle(group) + theme_bw()
  print(p)
}
```



```{r}
# considering technique

null_dist <- read.table("tpx_paramspace_AUC.ALL_noSingleNt.method.Npeaks_version.noPROB_fitted.noT_pot_custom.technique.anova_exclude.gz"
                , header = F
                , col.names = c("param","pval"))

true_values <- read.table("tpx_paramspace_AUC.ALL_noSingleNt.method.Npeaks_version.noPROB_fitted.noT_pot_custom.technique.header_added.true_prediction"
                          , header = F
                          , col.names = c("param","pval"))

null_dist_split <- split(x = null_dist, f = null_dist$param)


for (group in groups) {
  true_pval <- true_values[which(true_values$param == group),2]
  empirical_pval <- sum(null_dist_split[[group]][["pval"]] < true_pval)/10000
  print(group)
  print(empirical_pval)
}

```





# Curve ROC

## BEST SET OF PARAMS IN GENERAL - inferred from lm

Top 1000
Human

```{r}
z <- read.table("tpx_paramspace_AUC.idr_overlap_top1000.human.best_general_params.header_added.gz"
              , header = T)

z_split<-split(z,z$ssRNA)

predictors <- c("Stability_best", "Stability_norm_overcount", "Stability_norm_undercount")

for (pred in predictors) {
  roc_matrix<-lapply(z_split, function(x){
    ssRNA_name<-levels(as.factor(x$ssRNA))
    predictor_name<-pred
    suppressMessages(roc(as.formula(paste(collapse = "~", c("neg_pos", predictor_name))), data= x, direction="<"))
  })

  labels <- levels(as.factor(z$ssRNA))

  for(i in seq_along(labels)){
    l<-labels[[i]]
    auc<-round(roc_matrix[[l]]$auc,3)
    labels[[i]]<-paste0(c(l,auc),collapse=" - ")
  }
  
  p<-ggroc(roc_matrix) +
  theme_classic(base_size = 10) +
  geom_segment(aes(x = 1, xend = 0, y = 0, yend = 1), color="darkgray", linetype="dashed",size=0.3) +
  theme(plot.margin = margin(1,2,1,2, "cm")
        , plot.title = element_text(hjust = 0.5)
        , legend.title = element_blank()
        , legend.position = c(0.85, 0.3)
        , legend.key.size = unit(0.4, "cm"))+
  coord_fixed() +
  scale_color_igv(labels = labels)

  print(p)
}
                          
```


Top 1000
Mouse


```{r}

z <- read.table("tpx_paramspace_AUC.idr_overlap_top1000.mouse.best_general_params.header_added.gz"
              , header = T)

z_split<-split(z,z$ssRNA)

predictors <- c("Stability_best", "Stability_norm_overcount", "Stability_norm_undercount")

for (pred in predictors) {
  roc_matrix<-lapply(z_split, function(x){
    ssRNA_name<-levels(as.factor(x$ssRNA))
    predictor_name<-pred
    suppressMessages(roc(as.formula(paste(collapse = "~", c("neg_pos", predictor_name))), data= x, direction="<"))
  })

  labels <- levels(as.factor(z$ssRNA))

  for(i in seq_along(labels)){
    l<-labels[[i]]
    auc<-round(roc_matrix[[l]]$auc,3)
    labels[[i]]<-paste0(c(l,auc),collapse=" - ")
  }
  
  p<-ggroc(roc_matrix) +
  theme_classic(base_size = 10) +
  geom_segment(aes(x = 1, xend = 0, y = 0, yend = 1), color="darkgray", linetype="dashed",size=0.3) +
  theme(plot.margin = margin(1,2,1,2, "cm")
        , plot.title = element_text(hjust = 0.5)
        , legend.title = element_blank()
        , legend.position = c(0.85, 0.3)
        , legend.key.size = unit(0.4, "cm"))+
  coord_fixed() +
  scale_color_igv(labels = labels)

  print(p)
}
                          
```


idr conservative only
Human

```{r}
z <- read.table("tpx_paramspace_AUC.idr_conservative.human.best_general_params.header_added.gz"
              , header = T)

z_split<-split(z,z$ssRNA)

predictors <- c("Stability_best", "Stability_norm_overcount", "Stability_norm_undercount","t_pot_norm")

for (pred in predictors) {
  roc_matrix<-lapply(z_split, function(x){
    ssRNA_name<-levels(as.factor(x$ssRNA))
    predictor_name<-pred
    suppressMessages(roc(as.formula(paste(collapse = "~", c("neg_pos", predictor_name))), data= x, direction="<"))
  })

  labels <- levels(as.factor(z$ssRNA))

  for(i in seq_along(labels)){
    l<-labels[[i]]
    auc<-round(roc_matrix[[l]]$auc,3)
    labels[[i]]<-paste0(c(l,auc),collapse=" - ")
  }
  
  p<-ggroc(roc_matrix) +
  theme_classic(base_size = 10) +
  geom_segment(aes(x = 1, xend = 0, y = 0, yend = 1), color="darkgray", linetype="dashed",size=0.3) +
  theme(plot.margin = margin(1,2,1,2, "cm")
        , plot.title = element_text(hjust = 0.5)
        , legend.title = element_blank()
        , legend.position = c(0.85, 0.3)
        , legend.key.size = unit(0.4, "cm"))+
  coord_fixed() +
  scale_color_igv(labels = labels)

  print(p)
}
      
```



idr conservative only
Mouse

```{r}
z <- read.table("tpx_paramspace_AUC.idr_conservative.mouse.best_general_params.header_added.gz"
              , header = T)

z_split<-split(z,z$ssRNA)

predictors <- c("Stability_best", "Stability_norm_overcount", "Stability_norm_undercount", "t_pot_norm")

for (pred in predictors) {
  roc_matrix<-lapply(z_split, function(x){
    ssRNA_name<-levels(as.factor(x$ssRNA))
    predictor_name<-pred
    suppressMessages(roc(as.formula(paste(collapse = "~", c("neg_pos", predictor_name))), data= x, direction="<"))
  })

  labels <- levels(as.factor(z$ssRNA))

  for(i in seq_along(labels)){
    l<-labels[[i]]
    auc<-round(roc_matrix[[l]]$auc,3)
    labels[[i]]<-paste0(c(l,auc),collapse=" - ")
  }
  
  p<-ggroc(roc_matrix) +
  theme_classic(base_size = 10) +
  geom_segment(aes(x = 1, xend = 0, y = 0, yend = 1), color="darkgray", linetype="dashed",size=0.3) +
  theme(plot.margin = margin(1,2,1,2, "cm")
        , plot.title = element_text(hjust = 0.5)
        , legend.title = element_blank()
        , legend.position = c(0.85, 0.3)
        , legend.key.size = unit(0.4, "cm"))+
  coord_fixed() +
  scale_color_igv(labels = labels)

  print(p)
}
      
```





## BEST SET OF PARAMS FOR EACH lncRNA

```{r}
z2 <- read.table("best_single_params.matrix.gz"
              , header = T)

filter_table <- read.table("best_parameter_settings.tsv", header=F)

z_split2<-split(z2,z2$ssRNA)

### Select the best predictor for each ssRNA through filter file
z_split_predictors<-lapply(z_split2,function(x){
  ssRNA_name<-levels(as.factor(x$ssRNA))
  predictor_name<-filter_table[which(filter_table[,2]==ssRNA_name), 10]
  z_split_filt<-x[,c("ssRNA","neg_pos",predictor_name)]
})

### Create roc objects with defined direction
roc_matrix<-lapply(z_split_predictors, function(x){
  ssRNA_name<-levels(as.factor(x$ssRNA))
  predictor_name<-filter_table[which(filter_table[,2]==ssRNA_name), 10]
  suppressMessages(roc(as.formula(paste(collapse = "~", c("neg_pos", predictor_name))), data= x, direction="<"))
})

labels <- levels(as.factor(z2$ssRNA))

for(i in seq_along(labels)){
  l<-labels[[i]]
  auc<-round(roc_matrix[[l]]$auc,3)
  labels[[i]]<-paste0(c(l,auc),collapse=" - ")
}

### ROC plot
p<-ggroc(roc_matrix) +
  theme_classic(base_size = 10) +
  geom_segment(aes(x = 1, xend = 0, y = 0, yend = 1), color="darkgray", linetype="dashed",size=0.3) +
  theme(plot.margin = margin(1,2,1,2, "cm")
        , plot.title = element_text(hjust = 0.5)
        , legend.title = element_blank()
        , legend.position = c(0.85, 0.3)
        , legend.key.size = unit(0.4, "cm"))+
  coord_fixed() +
  scale_color_igv(labels = labels)

print(p)
```



# BARPLOT best general params (pivotal #181957228)

```{r}
# Interesting params
grp <- c("peak_method_all", "predictor", "min_len", "singleStrandedness")

# Best general params settings + data manipulation
general_param_set <- read.delim("general_parameter_settings.tsv"
                             , header = F
                             , col.names = c("peak_method_all","singleStrandedness","min_len","error_rate","guanine_rate","repeat_filter","consecutive_error","predictor"))
groups_factors <- c("peak_method_all","singleStrandedness","min_len","error_rate","guanine_rate","repeat_filter","consecutive_error","predictor")
general_param_set[,groups_factors] <- lapply(general_param_set[,groups_factors] , factor)
general_param_set$min_len <- as.factor(general_param_set$min_len)


# print barplot function
print_barplot <- function(df,fill_char){
  ggplot(data=df, aes_string(x="ssRNA", y="AUC", fill=fill_char)) +
  geom_bar(stat="identity", color="black", position=position_dodge(), size = .3)+  
  theme_pubr(base_size = 8) +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5)
        , legend.position = "bottom"
        , strip.background = element_blank()
        , strip.text.x = element_blank()
        , legend.key.size = unit(.8,"line")) +
  scale_fill_igv() +
  coord_cartesian(ylim = c(.25, 1)) +
  facet_wrap(~ssRNA, scale="free_x",nrow = 1) +
  xlab("")
}


# Create barplots
#pdf(file = "barplot_single_param_general_settings.pdf",width = 7, height = 4, paper = "a4")
for (g in grp) {
  general_param_set_grp <- general_param_set[, ! names(general_param_set) %in% g, drop = F]
  df_general_parmas <- df %>% inner_join(general_param_set_grp)
  df_general_parmas <- distinct(df_general_parmas)
  if(g == "peak_method") {
    peak_method <- read.delim("peak_method"
                    , header = F
                    , col.names = "peak_method")
    df_general_parmas <- df_general_parmas %>% complete(peak_method, ssRNA, fill = list(AUC = 0.25))
    df_general_parmas <- as.data.frame(df_general_parmas)
  }
  print(print_barplot(df_general_parmas,g))
}
#dev.off()
```









